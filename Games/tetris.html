<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Tetris Blast - Ghost Piece</title>
    <style>
        :root { --bg-color: #0a0a14; --accent: #00d2ff; }
        * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; }
        body {
            margin: 0; padding: 0; background-color: var(--bg-color); color: white;
            font-family: 'Segoe UI', Roboto, sans-serif; display: flex;
            flex-direction: column; align-items: center; justify-content: space-between;
            height: 100dvh; overflow: hidden; touch-action: none;
        }
        .bg-blur {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: -1;
            filter: blur(60px); opacity: 0.5;
            background: radial-gradient(circle at 10% 20%, #e74c3c 0%, transparent 40%),
                        radial-gradient(circle at 90% 80%, #3498db 0%, transparent 40%),
                        radial-gradient(circle at 50% 50%, #9b59b6 0%, transparent 50%);
            animation: moveBg 15s infinite alternate ease-in-out;
        }
        @keyframes moveBg { from { transform: scale(1); } to { transform: scale(1.1); } }
        .header { display: flex; align-items: center; justify-content: space-evenly; width: 100%; max-width: 400px; padding: 10px; }
        .ui-box { text-align: center; background: rgba(255,255,255,0.05); padding: 5px 15px; border-radius: 12px; backdrop-filter: blur(5px); border: 1px solid rgba(255,255,255,0.1); }
        #score { font-size: 28px; font-weight: 900; color: #f1c40f; margin: 0; }
        .next-container { width: 70px; height: 70px; display: flex; align-items: center; justify-content: center; position: relative; }
        #game-container { position: relative; flex-grow: 1; display: flex; align-items: center; justify-content: center; width: 100%; }
        canvas#gameCanvas { background: rgba(20, 30, 48, 0.8); backdrop-filter: blur(10px); border-radius: 12px; border: 1px solid rgba(255,255,255,0.1); max-height: 100%; }
        .controls { display: grid; grid-template-columns: repeat(5, 1fr); gap: 6px; padding: 10px; width: 100%; max-width: 450px; margin-bottom: env(safe-area-inset-bottom, 10px); }
        .btn { background: rgba(255, 255, 255, 0.1); border: none; color: white; padding: 20px 0; border-radius: 12px; font-size: 22px; font-weight: bold; cursor: pointer; user-select: none; }
        .btn:active { background: var(--accent); transform: scale(0.95); }
        .btn-reset { background: rgba(231, 76, 60, 0.3); color: #ff7675; }
        #game-over { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.9); display: none; flex-direction: column; justify-content: center; align-items: center; border-radius: 12px; z-index: 10; }
    </style>
</head>
<body>
    <div class="bg-blur"></div>
    <div class="header">
        <div class="ui-box"><div style="font-size: 9px; opacity: 0.7;">PONTOS</div><p id="score">0</p></div>
        <div class="ui-box next-container"><canvas id="nextCanvas" width="50" height="50"></canvas></div>
    </div>
    <div id="game-container">
        <canvas id="gameCanvas"></canvas>
        <div id="game-over">
            <h2 style="color: #e74c3c;">FIM!</h2>
            <p id="final-score">0</p>
            <button class="btn" onclick="resetGame()" style="background: #e74c3c; padding: 10px 30px;">Recomeçar</button>
        </div>
    </div>
    <div class="controls">
        <button class="btn btn-reset" onclick="resetGame()">↺</button>
        <button class="btn" onmousedown="startMove(-1)" ontouchstart="startMove(-1, event)" onmouseup="stopMove()" ontouchend="stopMove()">←</button>
        <button class="btn" onclick="playerRotate()">↻</button>
        <button class="btn" onmousedown="startFastDrop()" ontouchstart="startFastDrop(event)" onmouseup="stopFastDrop()" ontouchend="stopFastDrop()">↓</button>
        <button class="btn" onmousedown="startMove(1)" ontouchstart="startMove(1, event)" onmouseup="stopMove()" ontouchend="stopMove()">→</button>
    </div>

<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const nextCanvas = document.getElementById('nextCanvas');
const nctx = nextCanvas.getContext('2d');
const scoreElement = document.getElementById('score');

const COLS = 10; const ROWS = 20;
let cellSize, board, player, nextPiece, score, gameOver;
let dropCounter = 0; let dropInterval = 1000; let fastSpeed = 40; let lastTime = 0;
let particles = [];

const COLORS = ['#FF3E3E', '#2ECC71', '#3498DB', '#F1C40F', '#9B59B6', '#1ABC9C', '#E67E22'];
const PIECES = [
    [[0,0,0,0],[1,1,1,1],[0,0,0,0],[0,0,0,0]], [[1,1],[1,1]],
    [[0,1,0],[1,1,1],[0,0,0]], [[1,0,0],[1,1,1],[0,0,0]],
    [[0,0,1],[1,1,1],[0,0,0]], [[0,1,1],[1,1,0],[0,0,0]],
    [[1,1,0],[0,1,1],[0,0,0]]
];

function resize() {
    const availableHeight = window.innerHeight - 250;
    const availableWidth = window.innerWidth - 40;
    let w = Math.min(availableWidth, availableHeight / 2);
    if (w > 350) w = 350;
    canvas.width = w; canvas.height = w * 2;
    cellSize = canvas.width / COLS;
}

function createPiece() {
    const idx = Math.floor(Math.random() * PIECES.length);
    return { pos: {x: 0, y: 0}, matrix: PIECES[idx].map(row => [...row]), color: COLORS[idx] };
}

function drawNext() {
    nctx.clearRect(0, 0, nextCanvas.width, nextCanvas.height);
    const m = nextPiece.matrix; const s = 10;
    const offsetX = (nextCanvas.width - m[0].length * s) / 2;
    const offsetY = (nextCanvas.height - m.length * s) / 2;
    m.forEach((row, y) => row.forEach((val, x) => {
        if(val) { nctx.fillStyle = nextPiece.color; nctx.beginPath(); nctx.roundRect(offsetX + x*s, offsetY + y*s, s-1, s-1, 2); nctx.fill(); }
    }));
}

function resetGame() {
    board = Array(ROWS).fill().map(() => Array(COLS).fill(0));
    nextPiece = createPiece(); spawnPiece();
    score = 0; gameOver = false; document.getElementById('game-over').style.display = 'none';
    scoreElement.innerText = score;
}

function spawnPiece() {
    player = nextPiece; nextPiece = createPiece();
    player.pos = {x: Math.floor(COLS/2) - Math.floor(player.matrix[0].length/2), y: 0};
    drawNext();
}

function collide(board, player) {
    const [m, o] = [player.matrix, player.pos];
    for (let y = 0; y < m.length; ++y) {
        for (let x = 0; x < m[y].length; ++x) {
            if (m[y][x] !== 0 && (board[y + o.y] && board[y + o.y][x + o.x]) !== 0) return true;
        }
    }
    return false;
}

// Lógica da Sombra (Ghost Piece)
function getGhostPos() {
    let ghostPos = { x: player.pos.x, y: player.pos.y };
    while (!collide(board, { pos: { x: ghostPos.x, y: ghostPos.y + 1 }, matrix: player.matrix })) {
        ghostPos.y++;
    }
    return ghostPos;
}

function drawB(x, y, color, isGhost = false) {
    ctx.save();
    if (isGhost) {
        ctx.globalAlpha = 0.3; // Sombra bem suave
        ctx.strokeStyle = "white";
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.roundRect(x * cellSize + 2, y * cellSize + 2, cellSize - 4, cellSize - 4, 5);
        ctx.stroke();
    } else {
        ctx.fillStyle = color;
        ctx.beginPath();
        ctx.roundRect(x * cellSize + 1, y * cellSize + 1, cellSize - 2, cellSize - 2, 5);
        ctx.fill();
        ctx.fillStyle = "rgba(255,255,255,0.2)";
        ctx.fillRect(x * cellSize + 4, y * cellSize + 4, cellSize / 3, cellSize / 3);
    }
    ctx.restore();
}

function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    // Grade
    ctx.strokeStyle = "rgba(255, 255, 255, 0.05)";
    for(let i=0; i<=COLS; i++) { ctx.beginPath(); ctx.moveTo(i*cellSize,0); ctx.lineTo(i*cellSize,canvas.height); ctx.stroke(); }
    for(let i=0; i<=ROWS; i++) { ctx.beginPath(); ctx.moveTo(0,i*cellSize); ctx.lineTo(canvas.width,i*cellSize); ctx.stroke(); }

    // Desenhar Tabuleiro
    board.forEach((row, y) => row.forEach((val, x) => { if(val) drawB(x,y,val); }));

    // Desenhar Sombra (Ghost)
    const ghost = getGhostPos();
    player.matrix.forEach((row, y) => row.forEach((val, x) => {
        if(val) drawB(x + ghost.x, y + ghost.y, null, true);
    }));

    // Desenhar Peça Ativa
    player.matrix.forEach((row, y) => row.forEach((val, x) => {
        if(val) drawB(x + player.pos.x, y + player.pos.y, player.color);
    }));
    
    // Partículas
    particles = particles.filter(p => p.life > 0);
    particles.forEach(p => { 
        p.x += p.vx; p.y += p.vy; p.life -= 0.05; 
        ctx.globalAlpha = p.life; ctx.fillStyle = 'white'; ctx.beginPath(); ctx.arc(p.x, p.y, 2, 0, 7); ctx.fill(); 
    });
    ctx.globalAlpha = 1;
}

function playerDrop() {
    player.pos.y++;
    if(collide(board, player)) {
        player.pos.y--; merge(board, player); arenaSweep(); spawnPiece();
        if(collide(board, player)) { gameOver = true; document.getElementById('game-over').style.display = 'flex'; }
    }
    dropCounter = 0;
}

function playerRotate() {
    const oldM = player.matrix.map(row => [...row]);
    for (let y = 0; y < player.matrix.length; ++y) {
        for (let x = 0; x < y; ++x) { [player.matrix[x][y], player.matrix[y][x]] = [player.matrix[y][x], player.matrix[x][y]]; }
    }
    player.matrix.forEach(row => row.reverse());
    let offset = 1; const pos = player.pos.x;
    while (collide(board, player)) {
        player.pos.x += offset; offset = -(offset + (offset > 0 ? 1 : -1));
        if (offset > player.matrix[0].length) { player.matrix = oldM; player.pos.x = pos; return; }
    }
}

function arenaSweep() {
    let lines = 0;
    outer: for (let y = board.length - 1; y >= 0; --y) {
        for (let x = 0; x < board[y].length; ++x) { if (board[y][x] === 0) continue outer; }
        const row = board.splice(y, 1)[0].fill(0); board.unshift(row); y++; lines++;
        for(let x=0; x<COLS; x++) { for(let i=0; i<3; i++) particles.push({x: x*cellSize+cellSize/2, y: y*cellSize, life: 1, vx: Math.random()*6-3, vy: Math.random()*6-3}); }
    }
    if(lines > 0) { score += lines * 100 * lines; scoreElement.innerText = score; }
}

function merge(board, player) {
    player.matrix.forEach((row, y) => row.forEach((val, x) => { if(val) board[y+player.pos.y][x+player.pos.x] = player.color; }));
}

function update(time = 0) {
    const dt = time - lastTime; lastTime = time; dropCounter += dt;
    if(dropCounter > dropInterval) playerDrop();
    draw(); if(!gameOver) requestAnimationFrame(update);
}

let moveInt;
function startMove(d, e) { if(e) e.preventDefault(); playerMove(d); moveInt = setInterval(() => playerMove(d), 100); }
function stopMove() { clearInterval(moveInt); }
function playerMove(d) { player.pos.x += d; if(collide(board, player)) player.pos.x -= d; }
function startFastDrop(e) { if(e) e.preventDefault(); dropInterval = fastSpeed; }
function stopFastDrop() { dropInterval = 1000; }

window.addEventListener('resize', resize);
resize(); resetGame(); update();
</script>
</body>
</html>